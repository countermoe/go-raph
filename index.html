<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go-raph</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a0a; 
            overflow: hidden; 
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        canvas:focus { outline: none; }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.6);
            font-size: 11px;
            pointer-events: none;
        }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.6);
            font-size: 10px;
            text-align: right;
        }
        .fps {
            color: rgba(255,255,100,0.8);
        }
        .search-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
        }
        .search-container input {
            padding: 6px 10px;
            font-size: 14px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #1a1a1a;
            color: #fff;
            width: 240px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <div id="nodeCount">nodes: 0</div>
        <div id="edgeCount">edges: 0</div>
        <div style="margin-top: 8px; opacity: 0.5;">
            L: toggle labels<br>
            T: toggle trails<br>
            P: toggle physics<br>
            F: search packages<br>
            U: toggle UI<br>
            Mouse: drag to pan<br>
            Wheel: zoom in/out
        </div>
    </div>
    <div class="controls">
        <div class="fps" id="fps">0 fps</div>
        <div id="perf">0ms update</div>
        <div id="zoom">zoom: 1.0x</div>
        <div style="margin-top: 4px; opacity: 0.7;">
            <div>physics: <span id="physicsMode">on</span></div>
            <div>trails: <span id="trailsMode">on</span></div>
            <div>labels: <span id="labelsMode">hover</span></div>
            <div id="analysisMode" style="color: #666;">analysis: none</div>
        </div>
    </div>

    <!-- Search overlay -->
    <div class="search-container" id="searchContainer">
        <input type="text" id="searchInput" placeholder="Search package..." />
    </div>

    <script>
        class OptimizedGraph {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.w = this.canvas.width = window.innerWidth;
                this.h = this.canvas.height = window.innerHeight;
                this.cx = this.w / 2;
                this.cy = this.h / 2;
                
                this.nodes = [];
                this.edges = [];
                this.nodeMap = new Map();
                this.adjacencyList = new Map();
                
                this.time = 0;
                this.zoom = 1.0;
                this.targetZoom = 1.0;
                this.panX = 0;
                this.panY = 0;
                this.targetPanX = undefined;
                this.targetPanY = undefined;
                
                this.showAllLabels = false;
                this.enableTrails = true;
                this.enablePhysics = true;
                this.showUI = true;
                this.selectedNode = null;
                this.analysisMode = 'consumers'; // 'consumers' or 'dependencies'
                this.highlightedPaths = [];
                this.highlightedNodes = new Set();
                this.highlightedEdges = new Set();
                this.consumptionEdges = new Set();
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                this.updateTime = 0;
                
                // Spatial grid for performance
                this.spatialGrid = new Map();
                this.gridSize = 60;
                this.gridCols = 0;
                this.gridRows = 0;
                
                // Trails system
                this.trails = [];
                this.maxTrailLength = 15;
                this.trailFade = 0.94;
                
                // Search UI elements
                this.searchContainer = document.getElementById('searchContainer');
                this.searchInput = document.getElementById('searchInput');
                
                this.setupEventHandlers();
                this.connect();
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', () => this.resize());
            }
            
            setupEventHandlers() {
                let mouseDownPos = null;
                let dragThreshold = 5; // pixels - if mouse moves less than this, it's a click
                
                // Mouse drag for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    mouseDownPos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top,
                        clientX: e.clientX,
                        clientY: e.clientY
                    };
                    console.log('Mouse down at:', mouseDownPos);
                    this.isDragging = false; // Reset dragging state
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                    
                    if (mouseDownPos) {
                        const deltaX = e.clientX - mouseDownPos.clientX;
                        const deltaY = e.clientY - mouseDownPos.clientY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        if (distance > dragThreshold) {
                            this.isDragging = true;
                            this.panX += deltaX;
                            this.panY += deltaY;
                            mouseDownPos.clientX = e.clientX;
                            mouseDownPos.clientY = e.clientY;
                        }
                    } else {
                        // Update hover detection
                        const worldX = (this.mouseX - this.panX) / this.zoom;
                        const worldY = (this.mouseY - this.panY) / this.zoom;
                        this.hoveredNode = this.getNodeAt(worldX, worldY);
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    if (mouseDownPos && !this.isDragging) {
                        // This is a click, not a drag
                        const rect = this.canvas.getBoundingClientRect();
                        const screenX = e.clientX - rect.left;
                        const screenY = e.clientY - rect.top;
                        const worldX = (screenX - this.panX) / this.zoom;
                        const worldY = (screenY - this.panY) / this.zoom;
                        
                        console.log('Click detected!');
                        console.log('Screen coords:', screenX, screenY);
                        console.log('Pan:', this.panX, this.panY);
                        console.log('Zoom:', this.zoom);
                        console.log('World coords:', worldX, worldY);
                        
                        // Check all nodes for hit
                        let clickedNode = null;
                        let minDistance = Infinity;
                        
                        this.nodes.forEach(node => {
                            const dx = worldX - node.x;
                            const dy = worldY - node.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const size = this.getNodeSize(node);
                            const hitRadius = size + 10; // Larger hit area
                            
                            console.log(`Node ${node.label} at (${node.x}, ${node.y}), distance: ${distance}, hit radius: ${hitRadius}`);
                            
                            if (distance < hitRadius && distance < minDistance) {
                                minDistance = distance;
                                clickedNode = node;
                            }
                        });
                        
                        if (clickedNode) {
                            console.log('CLICKED NODE:', clickedNode.label, clickedNode.type);
                            this.selectNodeAndHighlightPaths(clickedNode);
                        } else {
                            console.log('No node clicked, clearing selection');
                            this.clearSelection();
                        }
                    }
                    
                    mouseDownPos = null;
                    this.isDragging = false;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    mouseDownPos = null;
                    this.isDragging = false;
                    this.hoveredNode = null;
                });
                
                // Smooth zoom with mouse wheel
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.1, Math.min(5.0, this.targetZoom * zoomFactor));
                    
                    // Store target zoom for smooth animation
                    this.targetZoom = newZoom;
                    
                    // Update pan to zoom towards mouse (but we'll animate to it)
                    const mouseX = e.clientX - this.canvas.getBoundingClientRect().left;
                    const mouseY = e.clientY - this.canvas.getBoundingClientRect().top;
                    
                    // Calculate new pan position for smooth transition
                    this.targetPanX = mouseX - (mouseX - this.panX) * (newZoom / this.zoom);
                    this.targetPanY = mouseY - (mouseY - this.panY) * (newZoom / this.zoom);
                });
                
                window.addEventListener('keydown', (e) => {
                    // If the search input is currently focused, ignore global shortcuts
                    if (document.activeElement === this.searchInput) {
                        return;
                    }
                    console.log('Key pressed:', e.key); // Debug logging
                    if (e.key === 'l' || e.key === 'L') {
                        this.showAllLabels = !this.showAllLabels;
                        console.log('Labels toggled to:', this.showAllLabels); // Debug logging
                        document.getElementById('labelsMode').textContent = this.showAllLabels ? 'all' : 'hover';
                    } else if (e.key === 't' || e.key === 'T') {
                        this.enableTrails = !this.enableTrails;
                        if (!this.enableTrails) this.trails = [];
                        document.getElementById('trailsMode').textContent = this.enableTrails ? 'on' : 'off';
                    } else if (e.key === 'p' || e.key === 'P') {
                        this.enablePhysics = !this.enablePhysics;
                        document.getElementById('physicsMode').textContent = this.enablePhysics ? 'on' : 'off';
                    } else if (e.key === 'f' || e.key === 'F') {
                        // Prevent the key character from being typed into the search bar when it opens
                        e.preventDefault();
                        if (this.searchContainer.style.display === 'block') {
                            this.hideSearch();
                        } else {
                            this.showSearch();
                        }
                    } else if (e.key === 'u' || e.key === 'U') {
                        this.showUI = !this.showUI;
                        const info = document.querySelector('.info');
                        const controls = document.querySelector('.controls');
                        info.style.display = this.showUI ? 'block' : 'none';
                        controls.style.display = this.showUI ? 'block' : 'none';
                    } else if (e.key === 'Escape') {
                        this.clearSelection();
                    } else if (e.key === 'c' || e.key === 'C') {
                        // Debug: log all nodes and their positions
                        console.log('=== ALL NODES ===');
                        this.nodes.forEach((node, i) => {
                            console.log(`${i}: ${node.label} (${node.type}) at (${node.x.toFixed(1)}, ${node.y.toFixed(1)})`);
                        });
                    } else if (e.key === 'x' || e.key === 'X') {
                        // Debug: test path finding with first external node
                        const testNode = this.nodes.find(n => n.type === 'external');
                        if (testNode) {
                            console.log('=== TESTING PATH FINDING ===');
                            console.log('Testing with node:', testNode.label);
                            this.selectNodeAndHighlightPaths(testNode);
                        } else {
                            console.log('No external node found for testing');
                        }
                    }
                });

                // Search input handlers
                this.searchInput.addEventListener('keydown', (e) => {
                    // Always prevent the keystroke from bubbling to the window handler
                    e.stopPropagation();

                    if (e.key === 'Enter') {
                        const term = e.target.value.trim();
                        if (term) {
                            this.searchPackageByName(term);
                            this.hideSearch();
                        }
                    } else if (e.key === 'Escape') {
                        this.hideSearch();
                        this.canvas.focus();
                    }
                });
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.w = this.canvas.width;
                this.h = this.canvas.height;
                this.cx = this.w / 2;
                this.cy = this.h / 2;
                this.rebuildSpatialGrid();
            }
            
            connect() {
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(protocol + '//' + location.host + '/ws');
                this.ws.onmessage = (e) => {
                    const data = JSON.parse(e.data);
                    if (data.graph) this.setGraph(data.graph);
                };
            }
            
            setGraph(graph) {
                const startTime = performance.now();
                
                console.log('Received graph data:', graph); // Debug logging
                console.log('Nodes:', graph.nodes.length, 'Edges:', graph.edges.length);
                
                // Log node types to debug yellow dots issue
                const nodeTypes = {};
                graph.nodes.forEach(node => {
                    nodeTypes[node.type] = (nodeTypes[node.type] || 0) + 1;
                });
                console.log('Node types:', nodeTypes);
                
                // Log orphaned nodes (nodes with no edges)
                const nodeIds = new Set(graph.nodes.map(n => n.id));
                const connectedNodes = new Set();
                graph.edges.forEach(edge => {
                    connectedNodes.add(edge.source);
                    connectedNodes.add(edge.target);
                });
                const orphanedNodes = graph.nodes.filter(n => !connectedNodes.has(n.id));
                if (orphanedNodes.length > 0) {
                    console.log('Orphaned nodes (no edges):', orphanedNodes);
                }
                
                // Clear existing data
                this.nodeMap.clear();
                this.adjacencyList.clear();
                
                // Initialize nodes with optimized positioning
                this.nodes = graph.nodes.map((n, i) => {
                    const angle = i * 0.618 * Math.PI * 2; // Golden angle
                    const radius = Math.sqrt(i) * 40; // Slightly increased spacing
                    const node = {
                        ...n,
                        x: this.cx + Math.cos(angle) * radius,
                        y: this.cy + Math.sin(angle) * radius,
                        vx: 0, vy: 0,
                        angle: Math.random() * Math.PI * 2,
                        speed: 0.01 + Math.random() * 0.02,
                        gridX: 0, gridY: 0 // Spatial grid position
                    };
                    this.nodeMap.set(n.id, node);
                    return node;
                });
                
                // Build adjacency list for O(1) neighbor lookup
                this.edges = graph.edges;
                this.edges.forEach(edge => {
                    if (!this.adjacencyList.has(edge.source)) {
                        this.adjacencyList.set(edge.source, []);
                    }
                    if (!this.adjacencyList.has(edge.target)) {
                        this.adjacencyList.set(edge.target, []);
                    }
                    this.adjacencyList.get(edge.source).push(edge.target);
                    this.adjacencyList.get(edge.target).push(edge.source);
                });
                
                this.rebuildSpatialGrid();
                
                document.getElementById('nodeCount').textContent = 'nodes: ' + this.nodes.length;
                document.getElementById('edgeCount').textContent = 'edges: ' + this.edges.length;
                
                // Auto-disable trails only for very large graphs
                if (this.nodes.length > 200) {
                    this.enableTrails = false;
                    this.maxTrailLength = 5;
                    document.getElementById('trailsMode').textContent = 'off (auto)';
                } else {
                    this.enableTrails = true;
                    document.getElementById('trailsMode').textContent = 'on';
                }
                
                console.log(`Graph setup took ${(performance.now() - startTime).toFixed(1)}ms`);
                
                // Ensure canvas can receive keyboard events
                this.canvas.tabIndex = 0;
                this.canvas.focus();
            }
            
            rebuildSpatialGrid() {
                this.spatialGrid = new Map();
                this.gridCols = Math.ceil(this.w / this.gridSize);
                this.gridRows = Math.ceil(this.h / this.gridSize);
            }
            
            updateSpatialGrid() {
                this.spatialGrid.clear();
                this.nodes.forEach(node => {
                    const gridX = Math.floor(node.x / this.gridSize);
                    const gridY = Math.floor(node.y / this.gridSize);
                    const key = gridX + ',' + gridY;
                    
                    node.gridX = gridX;
                    node.gridY = gridY;
                    
                    if (!this.spatialGrid.has(key)) {
                        this.spatialGrid.set(key, []);
                    }
                    this.spatialGrid.get(key).push(node);
                });
            }
            
            getNearbyNodes(node) {
                const nearby = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = (node.gridX + dx) + ',' + (node.gridY + dy);
                        const cellNodes = this.spatialGrid.get(key);
                        if (cellNodes) {
                            nearby.push(...cellNodes);
                        }
                    }
                }
                return nearby;
            }
            
            update() {
                const updateStart = performance.now();
                
                // Smooth zoom animation
                if (Math.abs(this.zoom - this.targetZoom) > 0.01) {
                    this.zoom += (this.targetZoom - this.zoom) * 0.15; // Smooth transition
                    document.getElementById('zoom').textContent = `zoom: ${this.zoom.toFixed(1)}x`;
                }
                
                // Smooth pan animation
                if (this.targetPanX !== undefined) {
                    this.panX += (this.targetPanX - this.panX) * 0.15;
                    this.panY += (this.targetPanY - this.panY) * 0.15;
                    
                    // Stop animation when close enough
                    if (Math.abs(this.panX - this.targetPanX) < 0.5) {
                        this.panX = this.targetPanX;
                        this.panY = this.targetPanY;
                        this.targetPanX = undefined;
                        this.targetPanY = undefined;
                    }
                }
                
                if (!this.enablePhysics) {
                    this.updateTime = performance.now() - updateStart;
                    return;
                }
                
                this.time += 0.012;
                
                // Update spatial grid less frequently for better performance
                if (this.frameCount % 3 === 0) {
                    this.updateSpatialGrid();
                }
                
                // Store trails more frequently for better visibility
                if (this.enableTrails && this.frameCount % 1 === 0) {
                    this.storeTrailFrame();
                }
                
                // Physics update with spatial optimization
                this.nodes.forEach(node => {
                    // Breathing motion
                    node.angle += node.speed * 0.7;
                    const breathe = Math.sin(node.angle) * 0.3;
                    
                    let fx = 0, fy = 0;
                    
                    // Only use spatial grid for repulsion if we have many nodes
                    const useGrid = this.nodes.length > 50;
                    const neighbors = useGrid ? this.getNearbyNodes(node) : this.nodes;
                    
                    // Repulsion with distance culling
                    neighbors.forEach(other => {
                        if (other === node) return;
                        
                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const distSq = dx*dx + dy*dy;
                        
                        if (distSq < 14400 && distSq > 1) { // 120px radius, avoid sqrt
                            const dist = Math.sqrt(distSq);
                            const force = 800 / distSq;
                            fx += (dx / dist) * force;
                            fy += (dy / dist) * force;
                        }
                    });
                    
                    // Center attraction
                    const centerDx = this.cx - node.x;
                    const centerDy = this.cy - node.y;
                    const depthFactor = 1 + (node.depth || 0) * 0.2;
                    fx += centerDx * 0.0008 * depthFactor;
                    fy += centerDy * 0.0008 * depthFactor;
                    
                    // Spring connections using adjacency list
                    const connectedIds = this.adjacencyList.get(node.id);
                    if (connectedIds) {
                        connectedIds.forEach(otherId => {
                            const other = this.nodeMap.get(otherId);
                            if (other) {
                                const dx = other.x - node.x;
                                const dy = other.y - node.y;
                                const distSq = dx*dx + dy*dy;
                                const dist = Math.sqrt(distSq) || 1;
                                const ideal = 90 + (node.depth || 0) * 15;
                                const spring = (dist - ideal) * 0.0008;
                                fx += (dx / dist) * spring;
                                fy += (dy / dist) * spring;
                            }
                        });
                    }
                    
                    // Velocity updates
                    node.vx += fx * 0.08;
                    node.vy += fy * 0.08;
                    node.vx *= 0.97;
                    node.vy *= 0.97;
                    
                    // Position updates
                    node.x += node.vx + breathe * 0.5;
                    node.y += node.vy + breathe * 0.5;
                });
                
                this.updateTime = performance.now() - updateStart;
            }
            
            storeTrailFrame() {
                if (this.nodes.length > 300) return; // Skip trails for very large graphs
                
                this.trails.push({
                    nodes: this.nodes.map(n => ({
                        x: n.x, y: n.y, 
                        size: this.getNodeSize(n),
                        color: this.getNodeColor(n)
                    })),
                    timestamp: this.time
                });
                
                if (this.trails.length > this.maxTrailLength) {
                    this.trails.shift();
                }
            }
            
            draw() {
                // Save context for transformations
                this.ctx.save();
                
                // Clear canvas
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                // Apply zoom and pan transformations
                this.ctx.translate(this.panX, this.panY);
                this.ctx.scale(this.zoom, this.zoom);
                
                // Draw trails (if enabled and not too many nodes)
                if (this.enableTrails && this.nodes.length < 300) {
                    this.drawTrails();
                }
                
                // Draw edges (with culling for large graphs)
                this.drawEdges();
                
                // Draw nodes
                this.drawNodes();
                
                // Restore context for UI elements
                this.ctx.restore();
                
                // Draw labels (in screen space, not world space)
                if (this.hoveredNode) {
                    this.drawLabel(this.hoveredNode);
                }
                if (this.showAllLabels) {
                    // Show labels for all nodes, but limit rendering for performance
                    const maxLabelsToShow = 300; // Increased limit
                    const nodesToLabel = this.nodes.length > maxLabelsToShow ? 
                        this.nodes.slice(0, maxLabelsToShow) : this.nodes;
                    nodesToLabel.forEach(node => this.drawLabel(node));
                }
            }
            
            drawTrails() {
                this.trails.forEach((trail, i) => {
                    const age = this.trails.length - i - 1;
                    const opacity = Math.pow(0.85, age); // Slower fade for more visible trails
                    
                    if (opacity > 0.02) { // Lower threshold for longer trails
                        trail.nodes.forEach(node => {
                            const alpha = opacity * 0.8; // Higher base opacity
                            this.ctx.fillStyle = node.color.replace('1)', alpha + ')');
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, node.size * 0.95, 0, Math.PI * 2); // Larger trail nodes
                            this.ctx.fill();
                        });
                    }
                });
            }
            
            drawEdges() {
                // Draw normal edges first
                this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)'; // More visible edges
                this.ctx.lineWidth = 1.0 / this.zoom; // Scale line width with zoom
                this.ctx.beginPath();
                
                // Batch edge drawing for better performance
                let edgeCount = 0;
                const maxEdges = this.nodes.length > 200 ? 500 : this.edges.length;
                
                for (const edge of this.edges) {
                    if (edgeCount++ > maxEdges) break;
                    
                    const edgeKey = `${edge.source}-${edge.target}`;
                    const reverseKey = `${edge.target}-${edge.source}`;
                    
                    // Skip highlighted edges for now
                    if (this.highlightedEdges.has(edgeKey) || this.highlightedEdges.has(reverseKey)) {
                        continue;
                    }
                    
                    const source = this.nodeMap.get(edge.source);
                    const target = this.nodeMap.get(edge.target);
                    if (source && target) {
                        this.ctx.moveTo(source.x, source.y);
                        this.ctx.lineTo(target.x, target.y);
                    }
                }
                this.ctx.stroke();
                
                // Draw highlighted edges with special styling
                if (this.highlightedEdges.size > 0) {
                    this.ctx.strokeStyle = 'rgba(100, 150, 255, 0.9)'; // Blue for dependency tree
                    this.ctx.lineWidth = 3.0 / this.zoom; // Thicker highlighted edges
                    this.ctx.shadowColor = 'rgba(100, 150, 255, 0.5)';
                    this.ctx.shadowBlur = 8 / this.zoom;
                    this.ctx.beginPath();
                    
                    for (const edge of this.edges) {
                        const edgeKey = `${edge.source}-${edge.target}`;
                        const reverseKey = `${edge.target}-${edge.source}`;
                        
                        if (this.highlightedEdges.has(edgeKey) || this.highlightedEdges.has(reverseKey)) {
                            const source = this.nodeMap.get(edge.source);
                            const target = this.nodeMap.get(edge.target);
                            if (source && target) {
                                this.ctx.moveTo(source.x, source.y);
                                this.ctx.lineTo(target.x, target.y);
                            }
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
            }
            
            drawNodes() {
                this.nodes.forEach(node => {
                    const size = this.getNodeSize(node);
                    const isHighlighted = this.highlightedNodes.has(node.id);
                    const isSelected = this.selectedNode && this.selectedNode.id === node.id;
                    
                    let color = this.getNodeColor(node);
                    let alpha = 0.8 + Math.sin(this.time + node.x * 0.005) * 0.2;
                    
                    // Dim non-highlighted nodes when selection is active
                    if (this.highlightedNodes.size > 0 && !isHighlighted) {
                        alpha *= 0.2; // More aggressive dimming to focus on dependency tree
                    }
                    
                    // Special styling for highlighted nodes (consumers in dependency tree)
                    if (isHighlighted && !isSelected) {
                        alpha = 1.0;
                        // Blue glow for consumers/dependents
                        this.ctx.shadowColor = 'rgba(100, 150, 255, 0.8)';
                        this.ctx.shadowBlur = size * 0.8;
                    }
                    
                    // Special styling for selected node (the dependency being analyzed)
                    if (isSelected) {
                        // Different colors for different analysis modes
                        const modeColor = this.analysisMode === 'consumers' ? 
                            'rgba(255, 100, 100, 1)' :  // Red for consumers mode
                            'rgba(100, 255, 100, 1)';   // Green for dependencies mode
                        
                        // Pulsing effect for selected node
                        const pulse = 1 + Math.sin(this.time * 3) * 0.3;
                        this.ctx.shadowColor = modeColor;
                        this.ctx.shadowBlur = size * pulse;
                        
                        // Draw selection ring with mode color
                        this.ctx.strokeStyle = modeColor;
                        this.ctx.lineWidth = 2 / this.zoom;
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, size + 4, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    // Main node
                    this.ctx.fillStyle = color.replace('1)', alpha + ')');
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Glow effect
                    if (this.nodes.length < 150 || node.type === 'main' || isHighlighted || isSelected) {
                        this.ctx.fill(); // Apply shadow
                    }
                    this.ctx.shadowBlur = 0;
                });
            }
            
            getNodeSize(node) {
                const base = { main: 8, package: 5, external: 3 }; // Simplified sizing
                return base[node.type] || 3;
            }
            
            getNodeColor(node) {
                const colors = {
                    main: 'rgba(255, 100, 100, 1)',     // Red - main module
                    package: 'rgba(100, 150, 255, 1)',  // Blue - local packages
                    external: 'rgba(255, 200, 100, 1)'  // Orange - external dependencies
                };
                return colors[node.type] || 'rgba(150, 150, 150, 1)';
            }
            
            getNodeAt(x, y) {
                for (const node of this.nodes) {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    const size = this.getNodeSize(node);
                    if (dx*dx + dy*dy < (size + 8) * (size + 8)) { // Larger hit area
                        return node;
                    }
                }
                return null;
            }
            
            drawLabel(node) {
                // Transform node position to screen coordinates
                const screenX = node.x * this.zoom + this.panX;
                const screenY = node.y * this.zoom + this.panY;
                const size = this.getNodeSize(node) * this.zoom;
                
                // Skip if off-screen (with larger margin for labels)
                if (screenX < -200 || screenX > this.w + 200 || screenY < -100 || screenY > this.h + 100) {
                    return;
                }
                
                const x = screenX;
                const y = screenY - size - 15; // More space above node
                
                let text = node.label;
                // Adjust text length based on zoom level
                const maxLength = Math.max(15, Math.min(30, Math.floor(20 * this.zoom)));
                if (text.length > maxLength) {
                    text = text.substring(0, maxLength - 2) + '..';
                }
                
                // Scale font with zoom, but keep readable
                const fontSize = Math.max(10, Math.min(16, 12 * this.zoom));
                this.ctx.font = `${fontSize}px SF Mono, Monaco, monospace`;
                const metrics = this.ctx.measureText(text);
                const textWidth = metrics.width;
                const textHeight = fontSize + 2;
                
                // Background with stronger opacity
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                const padding = 6;
                this.ctx.fillRect(x - textWidth/2 - padding, y - textHeight - 3, textWidth + padding*2, textHeight + 6);
                
                // Border
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x - textWidth/2 - padding, y - textHeight - 3, textWidth + padding*2, textHeight + 6);
                
                // Text with maximum contrast
                this.ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(text, x, y - 2);
            }
            
            updatePerformanceMetrics() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    document.getElementById('fps').textContent = this.fps + ' fps';
                    document.getElementById('perf').textContent = this.updateTime.toFixed(1) + 'ms update';
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }
            
            animate() {
                this.update();
                this.draw();
                this.updatePerformanceMetrics();
                requestAnimationFrame(() => this.animate());
            }
            
            selectNodeAndHighlightPaths(node) {
                console.log('=== SELECTING NODE FOR DEPENDENCY ANALYSIS ===');
                console.log('Selected node:', node);
                
                // Toggle mode if clicking the same node again
                if (this.selectedNode && this.selectedNode.id === node.id) {
                    this.analysisMode = this.analysisMode === 'consumers' ? 'dependencies' : 'consumers';
                    console.log('Toggling analysis mode to:', this.analysisMode);
                } else {
                    // New node selected, start with consumers
                    this.analysisMode = 'consumers';
                    console.log('New node selected, starting with consumers mode');
                }
                
                // Update UI indicator
                const modeElement = document.getElementById('analysisMode');
                if (modeElement) {
                    const modeText = this.analysisMode === 'consumers' ? 'consumers' : 'dependencies';
                    const modeColor = this.analysisMode === 'consumers' ? '#ff6464' : '#64ff64';
                    modeElement.textContent = `analysis: ${modeText}`;
                    modeElement.style.color = modeColor;
                    console.log('Updated UI indicator to:', modeText, 'with color:', modeColor);
                } else {
                    console.error('Could not find analysisMode element!');
                }
                
                this.selectedNode = node;
                this.highlightedPaths = [];
                this.highlightedNodes.clear();
                this.highlightedEdges.clear();
                
                if (this.analysisMode === 'consumers') {
                    // Show what depends on this node (consumers/reverse dependencies)
                    console.log('Finding all consumers of:', node.label, '(' + node.id + ')');
                    
                    const allConsumers = this.findAllConsumers(node.id);
                    
                    if (allConsumers.size > 0) {
                        console.log(`Found ${allConsumers.size} consumers:`, Array.from(allConsumers).map(id => {
                            const n = this.nodeMap.get(id);
                            return n ? n.label : id;
                        }));
                        
                        // Highlight the selected node
                        this.highlightedNodes.add(node.id);
                        
                        // Highlight all consumers
                        allConsumers.forEach(consumerId => {
                            this.highlightedNodes.add(consumerId);
                        });
                        
                        console.log('Highlighted nodes:', Array.from(this.highlightedNodes));
                        console.log('Highlighted edges:', Array.from(this.highlightedEdges));
                    } else {
                        console.log('No consumers found - this might be a leaf node');
                        // Just highlight the selected node itself
                        this.highlightedNodes.add(node.id);
                    }
                } else {
                    // Show what this node depends on (dependencies/forward dependencies)
                    console.log('Finding all dependencies of:', node.label, '(' + node.id + ')');
                    
                    const allDependencies = this.findAllDependencies(node.id);
                    
                    if (allDependencies.size > 0) {
                        console.log(`Found ${allDependencies.size} dependencies:`, Array.from(allDependencies).map(id => {
                            const n = this.nodeMap.get(id);
                            return n ? n.label : id;
                        }));
                        
                        // Highlight the selected node
                        this.highlightedNodes.add(node.id);
                        
                        // Highlight all dependencies
                        allDependencies.forEach(depId => {
                            this.highlightedNodes.add(depId);
                        });
                        
                        console.log('Highlighted nodes:', Array.from(this.highlightedNodes));
                        console.log('Highlighted edges:', Array.from(this.highlightedEdges));
                    } else {
                        console.log('No dependencies found - this might be a root node');
                        // Just highlight the selected node itself
                        this.highlightedNodes.add(node.id);
                    }
                }
            }
            
            findAllConsumers(targetNodeId) {
                console.log('=== REVERSE DEPENDENCY ANALYSIS ===');
                console.log('Finding consumers of:', targetNodeId);
                
                const consumers = new Set();
                const visited = new Set();
                const consumptionEdges = new Set(); // Track the actual consumption edges we find
                
                // Use DFS to find all nodes that transitively depend on the target
                const findConsumersRecursive = (nodeId, depth = 0) => {
                    if (visited.has(nodeId) || depth > 10) return; // Prevent infinite loops
                    visited.add(nodeId);
                    
                    console.log(`  ${'  '.repeat(depth)}Checking consumers of: ${nodeId}`);
                    
                    // Find all edges where this node is the SOURCE (things this node provides to)
                    this.edges.forEach(edge => {
                        if (edge.source === nodeId) {
                            console.log(`  ${'  '.repeat(depth)}  Found consumer: ${edge.source} → ${edge.target}`);
                            consumers.add(edge.target);
                            
                            // Track edge in both directions for drawing compatibility
                            consumptionEdges.add(`${edge.source}-${edge.target}`);
                            consumptionEdges.add(`${edge.target}-${edge.source}`);
                            
                            // Recursively find what depends on this consumer
                            findConsumersRecursive(edge.target, depth + 1);
                        }
                    });
                };
                
                findConsumersRecursive(targetNodeId);
                
                // Store the consumption edges for highlighting
                this.highlightedEdges = consumptionEdges;
                
                return consumers;
            }
            
            findAllDependencies(targetNodeId) {
                console.log('=== FORWARD DEPENDENCY ANALYSIS ===');
                console.log('Finding dependencies of:', targetNodeId);
                
                const dependencies = new Set();
                const visited = new Set();
                const dependencyEdges = new Set(); // Track the actual dependency edges we find
                
                // Use DFS to find all nodes that this node transitively depends on
                const findDependenciesRecursive = (nodeId, depth = 0) => {
                    if (visited.has(nodeId) || depth > 10) return; // Prevent infinite loops
                    visited.add(nodeId);
                    
                    console.log(`  ${'  '.repeat(depth)}Checking dependencies of: ${nodeId}`);
                    
                    // Find all edges where this node is the TARGET (things this node depends on)
                    this.edges.forEach(edge => {
                        if (edge.target === nodeId) {
                            console.log(`  ${'  '.repeat(depth)}  Found dependency: ${edge.source} → ${edge.target}`);
                            dependencies.add(edge.source);
                            
                            // Track edge in both directions for drawing compatibility
                            dependencyEdges.add(`${edge.source}-${edge.target}`);
                            dependencyEdges.add(`${edge.target}-${edge.source}`);
                            
                            // Recursively find what this dependency depends on
                            findDependenciesRecursive(edge.source, depth + 1);
                        }
                    });
                };
                
                findDependenciesRecursive(targetNodeId);
                
                // Store the dependency edges for highlighting
                this.highlightedEdges = dependencyEdges;
                
                return dependencies;
            }
            
            clearSelection() {
                this.selectedNode = null;
                this.highlightedPaths = [];
                this.highlightedNodes.clear();
                this.highlightedEdges.clear();
                
                // Reset UI indicator
                const modeElement = document.getElementById('analysisMode');
                modeElement.textContent = 'analysis: none';
                modeElement.style.color = '#666';
            }
            
            searchPackageByName(query) {
                const lower = query.toLowerCase();

                // Filter nodes that contain the substring (works for all types, incl. external)
                const matches = this.nodes.filter(n => n.label.toLowerCase().includes(lower));

                if (matches.length === 0) {
                    alert(`No packages found for "${query}"`);
                    return;
                }

                // Sort by relevance: earlier substring position, then shorter label length
                matches.sort((a, b) => {
                    const ai = a.label.toLowerCase().indexOf(lower);
                    const bi = b.label.toLowerCase().indexOf(lower);
                    if (ai !== bi) return ai - bi;
                    if (a.label.length !== b.label.length) return a.label.length - b.label.length;
                    // Tie-breaker: prefer 'package' and 'external' over 'main'
                    const priority = { package: 0, external: 1, main: 2 };
                    return (priority[a.type] || 3) - (priority[b.type] || 3);
                });

                // Use the top-ranked match
                const node = matches[0];
                this.selectNodeAndHighlightPaths(node);

                // Smoothly pan the view so the found node is centered
                this.targetPanX = this.cx - node.x * this.zoom;
                this.targetPanY = this.cy - node.y * this.zoom;
            }

            hideSearch() {
                if (this.searchContainer) {
                    this.searchContainer.style.display = 'none';
                    this.searchInput.blur();
                }
            }

            showSearch() {
                if (this.searchContainer) {
                    this.searchContainer.style.display = 'block';
                    this.searchInput.value = '';
                    this.searchInput.focus();
                }
            }
        }
        
        new OptimizedGraph();
    </script>
</body>
</html> 