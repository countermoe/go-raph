<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go-raph</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a0a; 
            overflow: hidden; 
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        }
        canvas { display: block; }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.6);
            font-size: 11px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <div id="nodeCount">nodes: 0</div>
        <div id="edgeCount">edges: 0</div>
        <div style="margin-top: 8px; opacity: 0.5;">press L to toggle labels</div>
    </div>

    <script>
        class MinimalGraph {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.edges = [];
                this.time = 0;
                this.trails = []; // Store trail history
                this.maxTrailLength = 15;
                
                this.resize();
                this.connect();
                this.animate();
                this.setupInteraction();
                
                window.addEventListener('resize', () => this.resize());
            }
            
            setupInteraction() {
                this.hoveredNode = null;
                this.showAllLabels = false;
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouseX = 0;
                    this.mouseY = 0;
                    this.hoveredNode = null;
                });
                
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'l' || e.key === 'L') {
                        this.showAllLabels = !this.showAllLabels;
                    }
                });
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.w = this.canvas.width;
                this.h = this.canvas.height;
                this.cx = this.w / 2;
                this.cy = this.h / 2;
            }
            
            connect() {
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(protocol + '//' + location.host + '/ws');
                this.ws.onmessage = (e) => {
                    const data = JSON.parse(e.data);
                    if (data.graph) this.setGraph(data.graph);
                };
            }
            
            setGraph(graph) {
                this.nodes = graph.nodes.map((n, i) => ({
                    ...n,
                    x: this.cx + Math.cos(i * 0.618) * 200,
                    y: this.cy + Math.sin(i * 0.618) * 200,
                    vx: 0, vy: 0,
                    angle: Math.random() * Math.PI * 2,
                    speed: 0.01 + Math.random() * 0.02
                }));
                this.edges = graph.edges;
                
                document.getElementById('nodeCount').textContent = 'nodes: ' + this.nodes.length;
                document.getElementById('edgeCount').textContent = 'edges: ' + this.edges.length;
            }
            
            update() {
                this.time += 0.012;
                
                // Check for hover
                this.hoveredNode = this.getNodeAt(this.mouseX || 0, this.mouseY || 0);
                
                // Store current frame for trails
                this.trails.push({
                    nodes: this.nodes.map(n => ({
                        x: n.x, y: n.y, 
                        size: this.getNodeSize(n),
                        color: this.getNodeColor(n),
                        type: n.type
                    })),
                    edges: this.edges.map(edge => {
                        const source = this.nodes.find(n => n.id === edge.source);
                        const target = this.nodes.find(n => n.id === edge.target);
                        return source && target ? {
                            x1: source.x, y1: source.y,
                            x2: target.x, y2: target.y
                        } : null;
                    }).filter(Boolean),
                    timestamp: this.time
                });
                
                // Limit trail length
                if (this.trails.length > this.maxTrailLength) {
                    this.trails.shift();
                }
                
                // More natural organic movement
                this.nodes.forEach((node, i) => {
                    const others = this.nodes.filter((_, j) => j !== i);
                    
                    // Gentler breathing motion
                    node.angle += node.speed * 0.7;
                    const breathe = Math.sin(node.angle) * 0.3;
                    
                    // Smoother repulsion
                    let fx = 0, fy = 0;
                    others.forEach(other => {
                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        if (dist < 120) {
                            const force = 800 / (dist * dist);
                            fx += (dx / dist) * force;
                            fy += (dy / dist) * force;
                        }
                    });
                    
                    // Gentle center attraction with depth
                    const centerDx = this.cx - node.x;
                    const centerDy = this.cy - node.y;
                    const depthFactor = 1 + node.depth * 0.2;
                    fx += centerDx * 0.0008 * depthFactor;
                    fy += centerDy * 0.0008 * depthFactor;
                    
                    // Spring connections
                    this.edges.forEach(edge => {
                        const other = this.nodes.find(n => 
                            (n.id === edge.target && node.id === edge.source) ||
                            (n.id === edge.source && node.id === edge.target)
                        );
                        if (other) {
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                            const ideal = 90 + node.depth * 15;
                            const spring = (dist - ideal) * 0.0008;
                            fx += (dx / dist) * spring;
                            fy += (dy / dist) * spring;
                        }
                    });
                    
                    // Smoother velocity updates
                    node.vx += fx * 0.08;
                    node.vy += fy * 0.08;
                    node.vx *= 0.97;
                    node.vy *= 0.97;
                    
                    // Natural movement with gentle breathing
                    node.x += node.vx + breathe * 0.5;
                    node.y += node.vy + breathe * 0.5;
                });
            }
            
            draw() {
                // Clear canvas completely
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                // Draw trails with subtle fading opacity
                this.trails.forEach((trail, i) => {
                    const age = this.trails.length - i - 1;
                    const opacity = Math.pow(0.75, age);
                    
                    if (opacity > 0.02) {
                        // Draw trail edges
                        this.ctx.strokeStyle = `rgba(100, 100, 100, ${opacity * 0.1})`;
                        this.ctx.lineWidth = 0.6;
                        trail.edges.forEach(edge => {
                            this.ctx.beginPath();
                            this.ctx.moveTo(edge.x1, edge.y1);
                            this.ctx.lineTo(edge.x2, edge.y2);
                            this.ctx.stroke();
                        });
                        
                        // Draw trail nodes
                        trail.nodes.forEach(node => {
                            const alpha = opacity * 0.4;
                            this.ctx.fillStyle = node.color.replace('1)', alpha + ')');
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
                            this.ctx.fill();
                        });
                    }
                });
                
                // Draw current frame (full opacity)
                // Draw edges
                this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                this.ctx.lineWidth = 0.8;
                this.edges.forEach(edge => {
                    const source = this.nodes.find(n => n.id === edge.source);
                    const target = this.nodes.find(n => n.id === edge.target);
                    if (source && target) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(source.x, source.y);
                        this.ctx.lineTo(target.x, target.y);
                        this.ctx.stroke();
                    }
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    const size = this.getNodeSize(node);
                    const color = this.getNodeColor(node);
                    const alpha = 0.8 + Math.sin(this.time + node.x * 0.005) * 0.2;
                    
                    // Main node body
                    this.ctx.fillStyle = color.replace('1)', alpha + ')');
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Minimal glow
                    this.ctx.shadowColor = color;
                    this.ctx.shadowBlur = size * 0.3;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                });
                
                // Draw hover label
                if (this.hoveredNode) {
                    this.drawLabel(this.hoveredNode);
                }
                
                // Draw all labels if toggled
                if (this.showAllLabels) {
                    this.nodes.forEach(node => this.drawLabel(node));
                }
            }
            
            getNodeSize(node) {
                const base = { main: 8, package: 4, internal: 3, external: 2 };
                return base[node.type] || 2;
            }
            
            getNodeColor(node) {
                const colors = {
                    main: 'rgba(255, 100, 100, 1)',
                    package: 'rgba(100, 150, 255, 1)', 
                    internal: 'rgba(100, 255, 150, 1)',
                    external: 'rgba(255, 200, 100, 1)'
                };
                return colors[node.type] || 'rgba(150, 150, 150, 1)';
            }
            
            getNodeAt(x, y) {
                for (const node of this.nodes) {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    const size = this.getNodeSize(node);
                    if (Math.sqrt(dx * dx + dy * dy) < size + 5) {
                        return node;
                    }
                }
                return null;
            }
            
            drawLabel(node) {
                const size = this.getNodeSize(node);
                const x = node.x;
                const y = node.y - size - 8;
                
                // Clean label text
                let text = node.label;
                if (text.length > 20) {
                    text = text.substring(0, 18) + '..';
                }
                
                // Measure text
                this.ctx.font = '11px SF Mono, Monaco, monospace';
                const metrics = this.ctx.measureText(text);
                const textWidth = metrics.width;
                const textHeight = 12;
                
                // Background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(x - textWidth/2 - 4, y - textHeight - 2, textWidth + 8, textHeight + 4);
                
                // Border
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 0.5;
                this.ctx.strokeRect(x - textWidth/2 - 4, y - textHeight - 2, textWidth + 8, textHeight + 4);
                
                // Text
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(text, x, y - 2);
            }
            
            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        new MinimalGraph();
    </script>
</body>
</html> 